"""\nUnit tests for Signal Generation Module\n"""\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src'))\n\nimport unittest\nimport pandas as pd\nimport numpy as np\nfrom signal_generation import SignalGenerator, SignalType, SignalStrength\n\nclass TestSignalGenerator(unittest.TestCase):\n    \"\"\"Test cases for SignalGenerator class\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data\"\"\"\n        # Configuration\n        self.config = {\n            'primary_timeframe': '1h',\n            'higher_timeframe': '4h',\n            'min_confidence': 0.5,\n            'use_multi_timeframe': False\n        }\n        \n        # Create synthetic OHLCV data\n        dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='1H')\n        n = len(dates)\n        \n        np.random.seed(42)\n        close = np.linspace(100, 120, n) + np.random.randn(n) * 2\n        \n        self.df = pd.DataFrame({\n            'open': close + np.random.randn(n) * 0.5,\n            'high': close + abs(np.random.randn(n)) * 1,\n            'low': close - abs(np.random.randn(n)) * 1,\n            'close': close,\n            'volume': np.random.randint(1000, 10000, n)\n        }, index=dates)\n        \n        # Create regimes (0: trending up, 1: ranging, 2: trending down)\n        self.regimes = pd.Series(\n            [0] * (n//3) + [1] * (n//3) + [2] * (n//3),\n            index=dates\n        )[:n]\n        \n        self.generator = SignalGenerator(self.config)\n    \n    def test_initialization(self):\n        \"\"\"Test SignalGenerator initialization\"\"\"\n        self.assertIsInstance(self.generator.config, dict)\n        self.assertEqual(self.generator.signals_history, [])\n    \n    def test_generate_signals(self):\n        \"\"\"Test signal generation\"\"\"\n        signals = self.generator.generate_signals(self.df, self.regimes)\n        \n        # Check output structure\n        self.assertIsInstance(signals, pd.DataFrame)\n        self.assertEqual(len(signals), len(self.df))\n        \n        # Check expected columns\n        expected_cols = ['regime', 'signal', 'strength', 'confidence', 'stop_loss', 'take_profit']\n        for col in expected_cols:\n            self.assertIn(col, signals.columns)\n        \n        # Check signal values are valid\n        valid_signals = [SignalType.BUY.value, SignalType.SELL.value, SignalType.HOLD.value]\n        self.assertTrue(signals['signal'].isin(valid_signals).all())\n        \n        # Check confidence is between 0 and 1\n        self.assertTrue((signals['confidence'] >= 0).all())\n        self.assertTrue((signals['confidence'] <= 1).all())\n    \n    def test_trending_up_strategy(self):\n        \"\"\"Test trending up strategy\"\"\"\n        # Filter to trending up regime\n        trending_up_mask = self.regimes == 0\n        trending_df = self.df[trending_up_mask]\n        trending_regimes = self.regimes[trending_up_mask]\n        \n        if len(trending_df) > 50:\n            signals = self.generator.generate_signals(trending_df, trending_regimes)\n            \n            # Should have some buy signals in trending up market\n            buy_signals = (signals['signal'] == SignalType.BUY.value).sum()\n            self.assertGreater(buy_signals, 0)\n    \n    def test_ranging_strategy(self):\n        \"\"\"Test ranging strategy\"\"\"\n        # Filter to ranging regime\n        ranging_mask = self.regimes == 1\n        ranging_df = self.df[ranging_mask]\n        ranging_regimes = self.regimes[ranging_mask]\n        \n        if len(ranging_df) > 50:\n            signals = self.generator.generate_signals(ranging_df, ranging_regimes)\n            \n            # Should have both buy and sell signals in ranging market\n            buy_signals = (signals['signal'] == SignalType.BUY.value).sum()\n            sell_signals = (signals['signal'] == SignalType.SELL.value).sum()\n            \n            # At least some trading activity\n            self.assertGreater(buy_signals + sell_signals, 0)\n    \n    def test_trending_down_strategy(self):\n        \"\"\"Test trending down strategy\"\"\"\n        # Filter to trending down regime\n        trending_down_mask = self.regimes == 2\n        trending_down_df = self.df[trending_down_mask]\n        trending_down_regimes = self.regimes[trending_down_mask]\n        \n        if len(trending_down_df) > 50:\n            signals = self.generator.generate_signals(trending_down_df, trending_down_regimes)\n            \n            # Should have some sell signals in trending down market\n            sell_signals = (signals['signal'] == SignalType.SELL.value).sum()\n            self.assertGreater(sell_signals, 0)\n    \n    def test_apply_filters(self):\n        \"\"\"Test signal filtering\"\"\"\n        signals = self.generator.generate_signals(self.df, self.regimes)\n        filtered_signals = self.generator.apply_filters(signals, self.df)\n        \n        # Check that filtering was applied\n        self.assertIsInstance(filtered_signals, pd.DataFrame)\n        self.assertEqual(len(filtered_signals), len(signals))\n        \n        # Filtered signals should have fewer or equal trading signals\n        original_trades = ((signals['signal'] != SignalType.HOLD.value).sum())\n        filtered_trades = ((filtered_signals['signal'] != SignalType.HOLD.value).sum())\n        self.assertLessEqual(filtered_trades, original_trades)\n    \n    def test_confidence_calculation(self):\n        \"\"\"Test confidence score calculation\"\"\"\n        # Test with all conditions true\n        conditions = [True, True, True, True]\n        confidence = self.generator._calculate_confidence(conditions)\n        self.assertEqual(confidence, 1.0)\n        \n        # Test with half conditions true\n        conditions = [True, False, True, False]\n        confidence = self.generator._calculate_confidence(conditions)\n        self.assertEqual(confidence, 0.5)\n        \n        # Test with no conditions\n        conditions = []\n        confidence = self.generator._calculate_confidence(conditions)\n        self.assertEqual(confidence, 0.0)\n    \n    def test_stop_loss_take_profit(self):\n        \"\"\"Test that stop loss and take profit are set\"\"\"\n        signals = self.generator.generate_signals(self.df, self.regimes)\n        \n        # Filter to actual trading signals\n        trade_signals = signals[signals['signal'] != SignalType.HOLD.value]\n        \n        if len(trade_signals) > 0:\n            # Should have stop loss and take profit for most signals\n            has_sl = trade_signals['stop_loss'].notna().sum()\n            has_tp = trade_signals['take_profit'].notna().sum()\n            \n            self.assertGreater(has_sl, 0)\n            self.assertGreater(has_tp, 0)\n    \n    def test_signal_strength(self):\n        \"\"\"Test that signal strength is assigned\"\"\"\n        signals = self.generator.generate_signals(self.df, self.regimes)\n        \n        # Check valid strength values\n        valid_strengths = [\n            SignalStrength.STRONG.value,\n            SignalStrength.MODERATE.value,\n            SignalStrength.WEAK.value\n        ]\n        self.assertTrue(signals['strength'].isin(valid_strengths).all())\n\nif __name__ == '__main__':\n    unittest.main()