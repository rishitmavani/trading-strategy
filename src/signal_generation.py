"""\nSignal Generation Module\nGenerates trading signals based on market regime and technical indicators\n"""\n\nimport numpy as np\nimport pandas as pd\nimport talib\nfrom typing import Dict, List, Tuple, Optional\nfrom enum import Enum\n\nclass SignalType(Enum):\n    """Enumeration for signal types"""\n    BUY = 1\n    SELL = -1\n    HOLD = 0\n\nclass SignalStrength(Enum):\n    """Enumeration for signal strength"""\n    STRONG = 2\n    MODERATE = 1\n    WEAK = 0\n\nclass SignalGenerator:\n    """\n    Generates trading signals based on:\n    - Market regime\n    - Technical indicators\n    - Multi-timeframe confirmation\n    - Risk management rules\n    """\n    \n    def __init__(self, config: Dict):\n        """\n        Initialize signal generator\n        \n        Args:\n            config: Configuration dictionary with strategy parameters\n        """\n        self.config = config\n        self.signals_history = []\n        \n    def generate_signals(self, df: pd.DataFrame, regime: pd.Series) -> pd.DataFrame:\n        """\n        Generate trading signals based on regime and indicators\n        \n        Args:\n            df: DataFrame with OHLCV data and indicators\n            regime: Series with regime labels\n            \n        Returns:\n            DataFrame with signals and metadata\n        """\n        signals = pd.DataFrame(index=df.index)\n        signals['regime'] = regime\n        \n        # Initialize signal columns\n        signals['signal'] = SignalType.HOLD.value\n        signals['strength'] = SignalStrength.WEAK.value\n        signals['confidence'] = 0.0\n        signals['stop_loss'] = np.nan\n        signals['take_profit'] = np.nan\n        \n        # Generate regime-specific signals\n        for idx in df.index:\n            current_regime = regime.loc[idx]\n            \n            if current_regime == 0:  # Trending Up\n                signal_data = self._trending_up_strategy(df, idx)\n            elif current_regime == 1:  # Ranging\n                signal_data = self._ranging_strategy(df, idx)\n            elif current_regime == 2:  # Trending Down\n                signal_data = self._trending_down_strategy(df, idx)\n            else:\n                continue\n            \n            # Update signals DataFrame\n            if signal_data:\n                for key, value in signal_data.items():\n                    signals.loc[idx, key] = value\n        \n        return signals\n    \n    def _trending_up_strategy(self, df: pd.DataFrame, idx) -> Optional[Dict]:\n        """\n        Strategy for trending up market\n        Focus on: Momentum, breakouts, pullback entries\n        \n        Args:\n            df: DataFrame with OHLCV data\n            idx: Current index\n            \n        Returns:\n            Dictionary with signal data or None\n        """\n        try:\n            # Get current and previous data\n            current = df.loc[idx]\n            lookback = min(50, len(df.loc[:idx]))\n            history = df.loc[:idx].tail(lookback)\n            \n            # Calculate indicators\n            sma_20 = history['close'].rolling(window=20).mean().iloc[-1]\n            sma_50 = history['close'].rolling(window=50).mean().iloc[-1] if len(history) >= 50 else sma_20\n            rsi = talib.RSI(history['close'], timeperiod=14).iloc[-1]\n            macd, signal, hist = talib.MACD(history['close'])\n            atr = talib.ATR(history['high'], history['low'], history['close'], timeperiod=14).iloc[-1]\n            \n            # Entry conditions\n            price_above_sma = current['close'] > sma_20\n            sma_trending = sma_20 > sma_50\n            rsi_not_overbought = rsi < 70\n            macd_bullish = hist.iloc[-1] > 0\n            \n            # Buy signal conditions\n            if price_above_sma and sma_trending and rsi_not_overbought and macd_bullish:\n                strength = SignalStrength.STRONG.value if rsi > 50 else SignalStrength.MODERATE.value\n                confidence = self._calculate_confidence([\n                    price_above_sma, sma_trending, rsi_not_overbought, macd_bullish\n                ])\n                \n                return {\n                    'signal': SignalType.BUY.value,\n                    'strength': strength,\n                    'confidence': confidence,\n                    'stop_loss': current['close'] - (2 * atr),\n                    'take_profit': current['close'] + (3 * atr)\n                }\n            \n            # Sell signal conditions (exit long)\n            elif current['close'] < sma_20 or rsi > 80 or hist.iloc[-1] < hist.iloc[-2] < 0:\n                return {\n                    'signal': SignalType.SELL.value,\n                    'strength': SignalStrength.MODERATE.value,\n                    'confidence': 0.7,\n                    'stop_loss': np.nan,\n                    'take_profit': np.nan\n                }\n            \n            return None\n            \n        except Exception as e:\n            print(f\"Error in trending_up_strategy at {idx}: {e}\")\n            return None\n    \n    def _ranging_strategy(self, df: pd.DataFrame, idx) -> Optional[Dict]:\n        """\n        Strategy for ranging market\n        Focus on: Mean reversion, support/resistance, oscillators\n        \n        Args:\n            df: DataFrame with OHLCV data\n            idx: Current index\n            \n        Returns:\n            Dictionary with signal data or None\n        """\n        try:\n            current = df.loc[idx]\n            lookback = min(50, len(df.loc[:idx]))\n            history = df.loc[:idx].tail(lookback)\n            \n            # Calculate indicators\n            bb_upper, bb_middle, bb_lower = talib.BBANDS(history['close'], timeperiod=20)\n            rsi = talib.RSI(history['close'], timeperiod=14).iloc[-1]\n            stoch_k, stoch_d = talib.STOCH(history['high'], history['low'], history['close'])\n            atr = talib.ATR(history['high'], history['low'], history['close'], timeperiod=14).iloc[-1]\n            \n            # Support and resistance levels\n            support = history['low'].rolling(window=20).min().iloc[-1]\n            resistance = history['high'].rolling(window=20).max().iloc[-1]\n            \n            # Buy at support/oversold\n            if (current['close'] <= bb_lower.iloc[-1] * 1.02 and rsi < 30) or \\\n               (current['close'] <= support * 1.01 and stoch_k.iloc[-1] < 20):\n                \n                confidence = self._calculate_confidence([\n                    rsi < 30,\n                    current['close'] <= bb_lower.iloc[-1] * 1.02,\n                    stoch_k.iloc[-1] < 20\n                ])\n                \n                return {\n                    'signal': SignalType.BUY.value,\n                    'strength': SignalStrength.MODERATE.value,\n                    'confidence': confidence,\n                    'stop_loss': current['close'] - (1.5 * atr),\n                    'take_profit': bb_middle.iloc[-1]\n                }\n            \n            # Sell at resistance/overbought\n            elif (current['close'] >= bb_upper.iloc[-1] * 0.98 and rsi > 70) or \\\n                 (current['close'] >= resistance * 0.99 and stoch_k.iloc[-1] > 80):\n                \n                confidence = self._calculate_confidence([\n                    rsi > 70,\n                    current['close'] >= bb_upper.iloc[-1] * 0.98,\n                    stoch_k.iloc[-1] > 80\n                ])\n                \n                return {\n                    'signal': SignalType.SELL.value,\n                    'strength': SignalStrength.MODERATE.value,\n                    'confidence': confidence,\n                    'stop_loss': current['close'] + (1.5 * atr),\n                    'take_profit': bb_middle.iloc[-1]\n                }\n            \n            return None\n            \n        except Exception as e:\n            print(f\"Error in ranging_strategy at {idx}: {e}\")\n            return None\n    \n    def _trending_down_strategy(self, df: pd.DataFrame, idx) -> Optional[Dict]:\n        """\n        Strategy for trending down market\n        Focus on: Short entries, breakdown, dead cat bounces\n        \n        Args:\n            df: DataFrame with OHLCV data\n            idx: Current index\n            \n        Returns:\n            Dictionary with signal data or None\n        """\n        try:\n            current = df.loc[idx]\n            lookback = min(50, len(df.loc[:idx]))\n            history = df.loc[:idx].tail(lookback)\n            \n            # Calculate indicators\n            sma_20 = history['close'].rolling(window=20).mean().iloc[-1]\n            sma_50 = history['close'].rolling(window=50).mean().iloc[-1] if len(history) >= 50 else sma_20\n            rsi = talib.RSI(history['close'], timeperiod=14).iloc[-1]\n            macd, signal, hist = talib.MACD(history['close'])\n            atr = talib.ATR(history['high'], history['low'], history['close'], timeperiod=14).iloc[-1]\n            \n            # Conditions\n            price_below_sma = current['close'] < sma_20\n            sma_downtrend = sma_20 < sma_50\n            rsi_not_oversold = rsi > 30\n            macd_bearish = hist.iloc[-1] < 0\n            \n            # Sell/Short signal conditions\n            if price_below_sma and sma_downtrend and rsi_not_oversold and macd_bearish:\n                strength = SignalStrength.STRONG.value if rsi < 50 else SignalStrength.MODERATE.value\n                confidence = self._calculate_confidence([\n                    price_below_sma, sma_downtrend, rsi_not_oversold, macd_bearish\n                ])\n                \n                return {\n                    'signal': SignalType.SELL.value,\n                    'strength': strength,\n                    'confidence': confidence,\n                    'stop_loss': current['close'] + (2 * atr),\n                    'take_profit': current['close'] - (3 * atr)\n                }\n            \n            # Buy signal (exit short or wait)\n            elif current['close'] > sma_20 or rsi < 20:\n                return {\n                    'signal': SignalType.BUY.value,\n                    'strength': SignalStrength.WEAK.value,\n                    'confidence': 0.5,\n                    'stop_loss': np.nan,\n                    'take_profit': np.nan\n                }\n            \n            return None\n            \n        except Exception as e:\n            print(f\"Error in trending_down_strategy at {idx}: {e}\")\n            return None\n    \n    def _calculate_confidence(self, conditions: List[bool]) -> float:\n        """\n        Calculate signal confidence based on number of confirmed conditions\n        \n        Args:\n            conditions: List of boolean conditions\n            \n        Returns:\n            Confidence score between 0 and 1\n        """\n        if not conditions:\n            return 0.0\n        \n        confirmed = sum(conditions)\n        total = len(conditions)\n        return confirmed / total\n    \n    def apply_filters(self, signals: pd.DataFrame, df: pd.DataFrame) -> pd.DataFrame:\n        """\n        Apply additional filters to signals\n        - Volume filter\n        - Volatility filter\n        - Time-based filter\n        \n        Args:\n            signals: DataFrame with raw signals\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            Filtered signals DataFrame\n        """\n        filtered_signals = signals.copy()\n        \n        # Volume filter: require above-average volume\n        avg_volume = df['volume'].rolling(window=20).mean()\n        low_volume_mask = df['volume'] < (avg_volume * 0.5)\n        filtered_signals.loc[low_volume_mask, 'signal'] = SignalType.HOLD.value\n        filtered_signals.loc[low_volume_mask, 'confidence'] *= 0.5\n        \n        # Volatility filter: reduce confidence in extreme volatility\n        returns = df['close'].pct_change()\n        volatility = returns.rolling(window=20).std()\n        high_vol_mask = volatility > volatility.quantile(0.90)\n        filtered_signals.loc[high_vol_mask, 'confidence'] *= 0.7\n        \n        # Confidence threshold filter\n        min_confidence = self.config.get('min_confidence', 0.5)\n        filtered_signals.loc[filtered_signals['confidence'] < min_confidence, 'signal'] = SignalType.HOLD.value\n        \n        return filtered_signals\n    \n    def generate_multi_timeframe_signals(self, data_dict: Dict[str, pd.DataFrame],\n                                        regimes_dict: Dict[str, pd.Series]) -> pd.DataFrame:\n        """\n        Generate signals with multi-timeframe confirmation\n        \n        Args:\n            data_dict: Dictionary of DataFrames for different timeframes\n            regimes_dict: Dictionary of regime Series for different timeframes\n            \n        Returns:\n            DataFrame with confirmed signals\n        """\n        # Get primary timeframe signals\n        primary_tf = self.config.get('primary_timeframe', '1h')\n        signals_primary = self.generate_signals(\n            data_dict[primary_tf],\n            regimes_dict[primary_tf]\n        )\n        \n        # Check higher timeframe alignment\n        higher_tf = self.config.get('higher_timeframe', '4h')\n        if higher_tf in data_dict:\n            signals_higher = self.generate_signals(\n                data_dict[higher_tf],\n                regimes_dict[higher_tf]\n            )\n            \n            # Align timeframes\n            signals_higher_aligned = signals_higher.reindex(\n                signals_primary.index,\n                method='ffill'\n            )\n            \n            # Require alignment\n            aligned_mask = (\n                signals_primary['signal'] * signals_higher_aligned['signal'] > 0\n            )\n            \n            signals_primary.loc[~aligned_mask, 'signal'] = SignalType.HOLD.value\n            signals_primary.loc[aligned_mask, 'confidence'] *= 1.2\n            signals_primary['confidence'] = signals_primary['confidence'].clip(upper=1.0)\n        \n        return signals_primary