"""\nData Collection Module\nHandles fetching and processing market data from various sources\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nimport talib\n\nclass DataCollector:\n    """\n    Collects and processes market data\n    Supports multiple data sources and timeframes\n    """\n    \n    def __init__(self, symbols: List[str], timeframes: List[str]):\n        """\n        Initialize data collector\n        \n        Args:\n            symbols: List of trading symbols (e.g., ['BTC-USD', 'ETH-USD'])\n            timeframes: List of timeframes (e.g., ['1h', '4h', '1d'])\n        """\n        self.symbols = symbols\n        self.timeframes = timeframes\n        self.data_cache = {}\n        \n    def fetch_data(self, symbol: str, timeframe: str, \n                   start_date: str, end_date: str = None) -> pd.DataFrame:\n        """\n        Fetch OHLCV data for a symbol and timeframe\n        \n        Args:\n            symbol: Trading symbol\n            timeframe: Timeframe (1m, 5m, 15m, 1h, 4h, 1d, etc.)\n            start_date: Start date (YYYY-MM-DD)\n            end_date: End date (YYYY-MM-DD), defaults to today\n            \n        Returns:\n            DataFrame with OHLCV data\n        """\n        if end_date is None:\n            end_date = datetime.now().strftime('%Y-%m-%d')\n        \n        # Map timeframe to yfinance interval\n        interval_map = {\n            '1m': '1m', '2m': '2m', '5m': '5m', '15m': '15m', '30m': '30m',\n            '1h': '1h', '90m': '90m', '4h': '4h', '1d': '1d', '1wk': '1wk'\n        }\n        \n        interval = interval_map.get(timeframe, '1h')\n        \n        try:\n            # Fetch data from yfinance\n            ticker = yf.Ticker(symbol)\n            df = ticker.history(start=start_date, end=end_date, interval=interval)\n            \n            # Standardize column names\n            df.columns = [col.lower() for col in df.columns]\n            \n            # Ensure we have required columns\n            required_cols = ['open', 'high', 'low', 'close', 'volume']\n            if not all(col in df.columns for col in required_cols):\n                raise ValueError(f"Missing required columns in data for {symbol}")\n            \n            # Cache the data\n            cache_key = f"{symbol}_{timeframe}"\n            self.data_cache[cache_key] = df\n            \n            return df\n            \n        except Exception as e:\n            print(f"Error fetching data for {symbol} at {timeframe}: {e}")\n            return pd.DataFrame()\n    \n    def add_technical_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n        """\n        Add technical indicators to OHLCV data\n        \n        Args:\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            DataFrame with added technical indicators\n        """\n        df = df.copy()\n        \n        try:\n            # Moving Averages\n            df['sma_20'] = talib.SMA(df['close'], timeperiod=20)\n            df['sma_50'] = talib.SMA(df['close'], timeperiod=50)\n            df['sma_200'] = talib.SMA(df['close'], timeperiod=200)\n            df['ema_12'] = talib.EMA(df['close'], timeperiod=12)\n            df['ema_26'] = talib.EMA(df['close'], timeperiod=26)\n            \n            # MACD\n            df['macd'], df['macd_signal'], df['macd_hist'] = talib.MACD(\n                df['close'], fastperiod=12, slowperiod=26, signalperiod=9\n            )\n            \n            # RSI\n            df['rsi'] = talib.RSI(df['close'], timeperiod=14)\n            \n            # Bollinger Bands\n            df['bb_upper'], df['bb_middle'], df['bb_lower'] = talib.BBANDS(\n                df['close'], timeperiod=20, nbdevup=2, nbdevdn=2\n            )\n            \n            # ATR (Average True Range)\n            df['atr'] = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)\n            \n            # ADX (Average Directional Index)\n            df['adx'] = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)\n            \n            # Stochastic\n            df['stoch_k'], df['stoch_d'] = talib.STOCH(\n                df['high'], df['low'], df['close'],\n                fastk_period=14, slowk_period=3, slowd_period=3\n            )\n            \n            # Volume indicators\n            df['volume_sma'] = talib.SMA(df['volume'], timeperiod=20)\n            df['volume_ratio'] = df['volume'] / df['volume_sma']\n            \n            # Price momentum\n            df['momentum'] = talib.MOM(df['close'], timeperiod=10)\n            df['roc'] = talib.ROC(df['close'], timeperiod=10)\n            \n        except Exception as e:\n            print(f"Error adding technical indicators: {e}")\n        \n        return df\n    \n    def fetch_multi_timeframe_data(self, symbol: str, \n                                   start_date: str, \n                                   end_date: str = None) -> Dict[str, pd.DataFrame]:\n        """\n        Fetch data for multiple timeframes\n        \n        Args:\n            symbol: Trading symbol\n            start_date: Start date\n            end_date: End date\n            \n        Returns:\n            Dictionary mapping timeframe to DataFrame\n        """\n        multi_tf_data = {}\n        \n        for tf in self.timeframes:\n            df = self.fetch_data(symbol, tf, start_date, end_date)\n            if not df.empty:\n                df = self.add_technical_indicators(df)\n                multi_tf_data[tf] = df\n        \n        return multi_tf_data\n    \n    def preprocess_data(self, df: pd.DataFrame) -> pd.DataFrame:\n        """\n        Preprocess data: handle missing values, outliers, etc.\n        \n        Args:\n            df: Raw DataFrame\n            \n        Returns:\n            Preprocessed DataFrame\n        """\n        df = df.copy()\n        \n        # Remove rows with missing OHLCV values\n        df = df.dropna(subset=['open', 'high', 'low', 'close', 'volume'])\n        \n        # Forward fill missing indicator values\n        df = df.fillna(method='ffill')\n        \n        # Remove remaining NaN values\n        df = df.dropna()\n        \n        # Check for outliers in price data\n        for col in ['open', 'high', 'low', 'close']:\n            q1 = df[col].quantile(0.01)\n            q99 = df[col].quantile(0.99)\n            df = df[(df[col] >= q1) & (df[col] <= q99)]\n        \n        return df\n    \n    def get_latest_data(self, symbol: str, timeframe: str, \n                       lookback_periods: int = 500) -> pd.DataFrame:\n        """\n        Get latest data for live trading\n        \n        Args:\n            symbol: Trading symbol\n            timeframe: Timeframe\n            lookback_periods: Number of periods to look back\n            \n        Returns:\n            DataFrame with latest data\n        """\n        end_date = datetime.now()\n        \n        # Calculate start date based on timeframe\n        if timeframe.endswith('m'):\n            minutes = int(timeframe[:-1])\n            start_date = end_date - timedelta(minutes=lookback_periods * minutes)\n        elif timeframe.endswith('h'):\n            hours = int(timeframe[:-1])\n            start_date = end_date - timedelta(hours=lookback_periods * hours)\n        elif timeframe.endswith('d'):\n            days = int(timeframe[:-1]) if timeframe[:-1] else 1\n            start_date = end_date - timedelta(days=lookback_periods * days)\n        else:\n            start_date = end_date - timedelta(days=lookback_periods)\n        \n        df = self.fetch_data(\n            symbol, timeframe,\n            start_date.strftime('%Y-%m-%d'),\n            end_date.strftime('%Y-%m-%d')\n        )\n        \n        if not df.empty:\n            df = self.add_technical_indicators(df)\n            df = self.preprocess_data(df)\n        \n        return df