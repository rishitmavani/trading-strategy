"""\nMarket Regime Detection Module\nImplements multiple methods for identifying market regimes\n"""\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.preprocessing import StandardScaler\nfrom typing import Dict, Tuple, Optional\nimport talib\n\nclass RegimeDetector:\n    """\n    Detects market regimes using multiple methods:\n    - Hidden Markov Model (HMM)\n    - Volatility-based classification\n    - Trend strength analysis\n    """\n    \n    def __init__(self, n_regimes: int = 3):\n        """\n        Initialize regime detector\n        \n        Args:\n            n_regimes: Number of market regimes to detect (default: 3)\n                      Typically: Trending Up, Ranging, Trending Down\n        """\n        self.n_regimes = n_regimes\n        self.hmm_model = None\n        self.scaler = StandardScaler()\n        self.regime_names = {\n            0: 'Trending Up',\n            1: 'Ranging',\n            2: 'Trending Down'\n        }\n        \n    def calculate_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        """\n        Calculate features for regime detection\n        \n        Args:\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            DataFrame with calculated features\n        """\n        features = pd.DataFrame(index=df.index)\n        \n        # Returns\n        features['returns'] = df['close'].pct_change()\n        features['log_returns'] = np.log(df['close'] / df['close'].shift(1))\n        \n        # Volatility measures\n        features['volatility'] = features['returns'].rolling(window=20).std()\n        features['parkinson_vol'] = np.sqrt(\n            (np.log(df['high'] / df['low']) ** 2) / (4 * np.log(2))\n        ).rolling(window=20).mean()\n        \n        # Trend indicators\n        features['sma_20'] = df['close'].rolling(window=20).mean()\n        features['sma_50'] = df['close'].rolling(window=50).mean()\n        features['trend_strength'] = (features['sma_20'] - features['sma_50']) / features['sma_50']\n        \n        # ADX for trend strength\n        features['adx'] = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)\n        \n        # RSI\n        features['rsi'] = talib.RSI(df['close'], timeperiod=14)\n        \n        # Volume\n        features['volume_ratio'] = df['volume'] / df['volume'].rolling(window=20).mean()\n        \n        # Price action\n        features['high_low_ratio'] = (df['high'] - df['low']) / df['close']\n        features['body_ratio'] = abs(df['close'] - df['open']) / (df['high'] - df['low'])\n        \n        return features.dropna()\n    \n    def detect_regime_hmm(self, df: pd.DataFrame) -> pd.Series:\n        """\n        Detect regime using Hidden Markov Model approach with Gaussian Mixture\n        \n        Args:\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            Series with regime labels\n        """\n        # Calculate features\n        features = self.calculate_features(df)\n        \n        # Select key features for regime detection\n        feature_cols = ['returns', 'volatility', 'trend_strength', 'adx', 'volume_ratio']\n        X = features[feature_cols].values\n        \n        # Standardize features\n        X_scaled = self.scaler.fit_transform(X)\n        \n        # Fit Gaussian Mixture Model\n        self.hmm_model = GaussianMixture(\n            n_components=self.n_regimes,\n            covariance_type='full',\n            max_iter=200,\n            random_state=42\n        )\n        \n        regimes = self.hmm_model.fit_predict(X_scaled)\n        \n        # Map regimes based on characteristics\n        regime_series = pd.Series(regimes, index=features.index)\n        regime_series = self._map_regimes(features, regime_series)\n        \n        return regime_series\n    \n    def _map_regimes(self, features: pd.DataFrame, regimes: pd.Series) -> pd.Series:\n        """\n        Map detected regimes to meaningful labels based on characteristics\n        \n        Args:\n            features: DataFrame with calculated features\n            regimes: Series with raw regime labels\n            \n        Returns:\n            Series with mapped regime labels\n        """\n        # Calculate average characteristics for each regime\n        regime_chars = []\n        for i in range(self.n_regimes):\n            mask = regimes == i\n            avg_trend = features.loc[mask, 'trend_strength'].mean()\n            avg_vol = features.loc[mask, 'volatility'].mean()\n            avg_adx = features.loc[mask, 'adx'].mean()\n            \n            regime_chars.append({\n                'regime': i,\n                'trend': avg_trend,\n                'volatility': avg_vol,\n                'adx': avg_adx\n            })\n        \n        # Sort by trend strength\n        regime_chars.sort(key=lambda x: x['trend'], reverse=True)\n        \n        # Map: highest trend = 0 (Trending Up), lowest = 2 (Trending Down), middle = 1 (Ranging)\n        regime_mapping = {\n            regime_chars[0]['regime']: 0,  # Trending Up\n            regime_chars[-1]['regime']: 2,  # Trending Down\n            regime_chars[1]['regime']: 1   # Ranging (if 3 regimes)\n        }\n        \n        return regimes.map(regime_mapping)\n    \n    def detect_regime_volatility(self, df: pd.DataFrame, \n                                 vol_window: int = 20) -> pd.Series:\n        """\n        Detect regime based on volatility levels\n        \n        Args:\n            df: DataFrame with OHLCV data\n            vol_window: Window for volatility calculation\n            \n        Returns:\n            Series with regime labels\n        """\n        returns = df['close'].pct_change()\n        volatility = returns.rolling(window=vol_window).std()\n        \n        # Calculate percentiles\n        vol_33 = volatility.quantile(0.33)\n        vol_67 = volatility.quantile(0.67)\n        \n        # Classify regimes\n        regimes = pd.Series(1, index=df.index)  # Default: medium volatility\n        regimes[volatility < vol_33] = 0  # Low volatility (ranging)\n        regimes[volatility > vol_67] = 2  # High volatility (trending/crisis)\n        \n        return regimes\n    \n    def detect_regime_trend(self, df: pd.DataFrame) -> pd.Series:\n        """\n        Detect regime based on trend strength (ADX and moving averages)\n        \n        Args:\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            Series with regime labels\n        """\n        # Calculate ADX\n        adx = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)\n        \n        # Calculate moving averages\n        sma_20 = df['close'].rolling(window=20).mean()\n        sma_50 = df['close'].rolling(window=50).mean()\n        \n        # Trend direction\n        trend_up = sma_20 > sma_50\n        \n        # Initialize regimes\n        regimes = pd.Series(1, index=df.index)  # Default: ranging\n        \n        # Strong trend up\n        regimes[(adx > 25) & trend_up] = 0\n        \n        # Strong trend down\n        regimes[(adx > 25) & ~trend_up] = 2\n        \n        # Weak trend (ranging)\n        regimes[adx <= 25] = 1\n        \n        return regimes\n    \n    def detect_regime_combined(self, df: pd.DataFrame) -> pd.Series:\n        """\n        Combine multiple regime detection methods for robust classification\n        \n        Args:\n            df: DataFrame with OHLCV data\n            \n        Returns:\n            Series with regime labels\n        """\n        # Get regimes from different methods\n        regime_hmm = self.detect_regime_hmm(df)\n        regime_vol = self.detect_regime_volatility(df)\n        regime_trend = self.detect_regime_trend(df)\n        \n        # Combine using voting\n        regime_df = pd.DataFrame({\n            'hmm': regime_hmm,\n            'vol': regime_vol,\n            'trend': regime_trend\n        })\n        \n        # Majority vote\n        combined_regime = regime_df.mode(axis=1)[0]\n        \n        return combined_regime\n    \n    def get_regime_stats(self, df: pd.DataFrame, regimes: pd.Series) -> Dict:\n        """\n        Calculate statistics for each regime\n        \n        Args:\n            df: DataFrame with OHLCV data\n            regimes: Series with regime labels\n            \n        Returns:\n            Dictionary with regime statistics\n        """\n        stats = {}\n        \n        for regime in range(self.n_regimes):\n            mask = regimes == regime\n            regime_data = df[mask]\n            \n            if len(regime_data) > 0:\n                returns = regime_data['close'].pct_change()\n                \n                stats[self.regime_names[regime]] = {\n                    'count': len(regime_data),\n                    'percentage': len(regime_data) / len(df) * 100,\n                    'avg_return': returns.mean() * 100,\n                    'volatility': returns.std() * 100,\n                    'sharpe': (returns.mean() / returns.std()) * np.sqrt(252) if returns.std() > 0 else 0,\n                    'max_drawdown': self._calculate_max_drawdown(regime_data['close'])\n                }\n        \n        return stats\n    \n    def _calculate_max_drawdown(self, prices: pd.Series) -> float:\n        """Calculate maximum drawdown"""\n        cumulative = (1 + prices.pct_change()).cumprod()\n        running_max = cumulative.expanding().max()\n        drawdown = (cumulative - running_max) / running_max\n        return drawdown.min() * 100