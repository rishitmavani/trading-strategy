"""\nUtility Functions\nHelper functions for the trading strategy\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Tuple\nimport yaml\nimport json\nfrom datetime import datetime\nimport logging\n\ndef setup_logging(log_file: str = 'trading_strategy.log', \n                 level: int = logging.INFO):\n    """\n    Setup logging configuration\n    \n    Args:\n        log_file: Path to log file\n        level: Logging level\n    """\n    logging.basicConfig(\n        level=level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler(log_file),\n            logging.StreamHandler()\n        ]\n    )\n\ndef load_config(config_path: str) -> Dict:\n    """\n    Load configuration from YAML file\n    \n    Args:\n        config_path: Path to config file\n        \n    Returns:\n        Configuration dictionary\n    """\n    with open(config_path, 'r') as f:\n        config = yaml.safe_load(f)\n    return config\n\ndef save_results(results: Dict, output_path: str):\n    """\n    Save results to JSON file\n    \n    Args:\n        results: Results dictionary\n        output_path: Output file path\n    """\n    # Convert pandas objects to serializable format\n    serializable_results = {}\n    for key, value in results.items():\n        if isinstance(value, pd.DataFrame):\n            serializable_results[key] = value.to_dict('records')\n        elif isinstance(value, pd.Series):\n            serializable_results[key] = value.to_dict()\n        elif isinstance(value, np.ndarray):\n            serializable_results[key] = value.tolist()\n        else:\n            serializable_results[key] = value\n    \n    with open(output_path, 'w') as f:\n        json.dump(serializable_results, f, indent=4, default=str)\n\ndef calculate_position_size(capital: float, \n                          risk_per_trade: float,\n                          entry_price: float,\n                          stop_loss: float) -> float:\n    """\n    Calculate position size based on risk management\n    \n    Args:\n        capital: Available capital\n        risk_per_trade: Risk percentage per trade (e.g., 0.02 for 2%)\n        entry_price: Entry price\n        stop_loss: Stop loss price\n        \n    Returns:\n        Position size in units\n    """\n    risk_amount = capital * risk_per_trade\n    price_risk = abs(entry_price - stop_loss)\n    \n    if price_risk == 0:\n        return 0\n    \n    position_size = risk_amount / price_risk\n    return position_size\n\ndef format_currency(value: float) -> str:\n    """Format value as currency"""\n    return f\"${value:,.2f}\"\n\ndef format_percentage(value: float) -> str:\n    """Format value as percentage"""\n    return f\"{value:.2f}%\"\n\ndef resample_data(df: pd.DataFrame, target_timeframe: str) -> pd.DataFrame:\n    """\n    Resample data to different timeframe\n    \n    Args:\n        df: DataFrame with OHLCV data\n        target_timeframe: Target timeframe (e.g., '1H', '4H', '1D')\n        \n    Returns:\n        Resampled DataFrame\n    """\n    resampled = df.resample(target_timeframe).agg({\n        'open': 'first',\n        'high': 'max',\n        'low': 'min',\n        'close': 'last',\n        'volume': 'sum'\n    })\n    \n    return resampled.dropna()\n\ndef validate_data(df: pd.DataFrame) -> Tuple[bool, List[str]]:\n    """\n    Validate OHLCV data quality\n    \n    Args:\n        df: DataFrame with OHLCV data\n        \n    Returns:\n        Tuple of (is_valid, error_messages)\n    """\n    errors = []\n    \n    # Check required columns\n    required_cols = ['open', 'high', 'low', 'close', 'volume']\n    missing_cols = [col for col in required_cols if col not in df.columns]\n    if missing_cols:\n        errors.append(f\"Missing columns: {missing_cols}\")\n    \n    # Check for missing values\n    if df[required_cols].isnull().any().any():\n        errors.append(\"Data contains missing values\")\n    \n    # Check high >= low\n    if (df['high'] < df['low']).any():\n        errors.append(\"High price is less than low price in some rows\")\n    \n    # Check high >= close and close >= low\n    if ((df['high'] < df['close']) | (df['close'] < df['low'])).any():\n        errors.append(\"Close price is outside high-low range in some rows\")\n    \n    # Check for negative prices\n    if (df[['open', 'high', 'low', 'close']] <= 0).any().any():\n        errors.append(\"Data contains negative or zero prices\")\n    \n    # Check for negative volume\n    if (df['volume'] < 0).any():\n        errors.append(\"Data contains negative volume\")\n    \n    is_valid = len(errors) == 0\n    return is_valid, errors\n\ndef print_trade_summary(trade: Dict):\n    """\n    Print formatted trade summary\n    \n    Args:\n        trade: Trade dictionary\n    """\n    print(\"\\n" + \"="*60)\n    print(\"TRADE SUMMARY\")\n    print(\"=\"*60)\n    print(f\"Type:        {trade['type']}\")\n    print(f\"Entry Date:  {trade['entry_date']}\")\n    print(f\"Exit Date:   {trade['exit_date']}\")\n    print(f\"Entry Price: {format_currency(trade['entry_price'])}\")\n    print(f\"Exit Price:  {format_currency(trade['exit_price'])}\")\n    print(f\"Size:        {trade['size']:.4f} units\")\n    print(f\"P&L:         {format_currency(trade['pnl'])}\")\n    print(f\"Return:      {format_percentage(trade['return'])}\")\n    print(\"=\"*60)\n\ndef get_timestamp() -> str:\n    """Get current timestamp as string"""\n    return datetime.now().strftime('%Y%m%d_%H%M%S')\n\ndef calculate_risk_reward_ratio(entry_price: float, \n                               stop_loss: float,\n                               take_profit: float) -> float:\n    """\n    Calculate risk-reward ratio\n    \n    Args:\n        entry_price: Entry price\n        stop_loss: Stop loss price\n        take_profit: Take profit price\n        \n    Returns:\n        Risk-reward ratio\n    """\n    risk = abs(entry_price - stop_loss)\n    reward = abs(take_profit - entry_price)\n    \n    if risk == 0:\n        return 0\n    \n    return reward / risk