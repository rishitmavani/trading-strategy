"""\nBacktesting Module\nTests trading strategies on historical data\n"""\n\nimport numpy as np\nimport pandas as pd\nfrom typing import Dict, List, Tuple\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\nclass Backtester:\n    """\n    Backtests trading strategies and calculates performance metrics\n    """\n    \n    def __init__(self, initial_capital: float = 10000, \n                 commission: float = 0.001,\n                 slippage: float = 0.0005):\n        """\n        Initialize backtester\n        \n        Args:\n            initial_capital: Starting capital\n            commission: Commission rate (0.001 = 0.1%)\n            slippage: Slippage rate (0.0005 = 0.05%)\n        """\n        self.initial_capital = initial_capital\n        self.commission = commission\n        self.slippage = slippage\n        self.trades = []\n        self.equity_curve = []\n        \n    def run_backtest(self, df: pd.DataFrame, signals: pd.DataFrame) -> Dict:\n        """\n        Run backtest on historical data with signals\n        \n        Args:\n            df: DataFrame with OHLCV data\n            signals: DataFrame with trading signals\n            \n        Returns:\n            Dictionary with backtest results\n        """\n        # Initialize portfolio\n        capital = self.initial_capital\n        position = 0  # 0: no position, 1: long, -1: short\n        entry_price = 0\n        position_size = 0\n        \n        # Track equity\n        equity = []\n        trades = []\n        \n        # Iterate through data\n        for idx in df.index:\n            current_price = df.loc[idx, 'close']\n            signal = signals.loc[idx, 'signal']\n            \n            # Calculate current equity\n            if position == 1:  # Long position\n                current_equity = capital + (position_size * (current_price - entry_price))\n            elif position == -1:  # Short position\n                current_equity = capital - (position_size * (current_price - entry_price))\n            else:\n                current_equity = capital\n            \n            equity.append({\n                'date': idx,\n                'equity': current_equity,\n                'position': position,\n                'price': current_price\n            })\n            \n            # Process signals\n            if signal == 1 and position != 1:  # Buy signal\n                # Close short if exists\n                if position == -1:\n                    pnl = position_size * (entry_price - current_price)\n                    pnl -= position_size * entry_price * self.commission  # Entry commission\n                    pnl -= position_size * current_price * (self.commission + self.slippage)  # Exit\n                    capital += pnl\n                    \n                    trades.append({\n                        'entry_date': entry_date,\n                        'exit_date': idx,\n                        'type': 'SHORT',\n                        'entry_price': entry_price,\n                        'exit_price': current_price,\n                        'size': position_size,\n                        'pnl': pnl,\n                        'return': (pnl / (position_size * entry_price)) * 100\n                    })\n                \n                # Open long\n                position = 1\n                entry_date = idx\n                entry_price = current_price * (1 + self.slippage)\n                position_size = (capital * 0.95) / entry_price  # Use 95% of capital\n                capital -= position_size * entry_price * self.commission\n                \n            elif signal == -1 and position != -1:  # Sell signal\n                # Close long if exists\n                if position == 1:\n                    pnl = position_size * (current_price - entry_price)\n                    pnl -= position_size * entry_price * self.commission\n                    pnl -= position_size * current_price * (self.commission + self.slippage)\n                    capital += pnl\n                    \n                    trades.append({\n                        'entry_date': entry_date,\n                        'exit_date': idx,\n                        'type': 'LONG',\n                        'entry_price': entry_price,\n                        'exit_price': current_price,\n                        'size': position_size,\n                        'pnl': pnl,\n                        'return': (pnl / (position_size * entry_price)) * 100\n                    })\n                \n                # Open short\n                position = -1\n                entry_date = idx\n                entry_price = current_price * (1 - self.slippage)\n                position_size = (capital * 0.95) / entry_price\n                capital -= position_size * entry_price * self.commission\n        \n        # Close any remaining position\n        if position != 0:\n            current_price = df.iloc[-1]['close']\n            if position == 1:\n                pnl = position_size * (current_price - entry_price)\n            else:\n                pnl = position_size * (entry_price - current_price)\n            \n            pnl -= position_size * current_price * (self.commission + self.slippage)\n            capital += pnl\n            \n            trades.append({\n                'entry_date': entry_date,\n                'exit_date': df.index[-1],\n                'type': 'LONG' if position == 1 else 'SHORT',\n                'entry_price': entry_price,\n                'exit_price': current_price,\n                'size': position_size,\n                'pnl': pnl,\n                'return': (pnl / (position_size * entry_price)) * 100\n            })\n        \n        # Store results\n        self.trades = pd.DataFrame(trades)\n        self.equity_curve = pd.DataFrame(equity)\n        \n        # Calculate metrics\n        metrics = self.calculate_metrics()\n        \n        return {\n            'trades': self.trades,\n            'equity_curve': self.equity_curve,\n            'metrics': metrics\n        }\n    \n    def calculate_metrics(self) -> Dict:\n        """\n        Calculate performance metrics\n        \n        Returns:\n            Dictionary with performance metrics\n        """\n        if self.trades.empty or self.equity_curve.empty:\n            return {}\n        \n        # Basic metrics\n        total_trades = len(self.trades)\n        winning_trades = len(self.trades[self.trades['pnl'] > 0])\n        losing_trades = len(self.trades[self.trades['pnl'] < 0])\n        \n        # Returns\n        total_return = ((self.equity_curve.iloc[-1]['equity'] - self.initial_capital) / \n                       self.initial_capital) * 100\n        \n        # Win rate\n        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0\n        \n        # Average trade\n        avg_win = self.trades[self.trades['pnl'] > 0]['pnl'].mean() if winning_trades > 0 else 0\n        avg_loss = abs(self.trades[self.trades['pnl'] < 0]['pnl'].mean()) if losing_trades > 0 else 0\n        \n        # Profit factor\n        gross_profit = self.trades[self.trades['pnl'] > 0]['pnl'].sum()\n        gross_loss = abs(self.trades[self.trades['pnl'] < 0]['pnl'].sum())\n        profit_factor = gross_profit / gross_loss if gross_loss > 0 else np.inf\n        \n        # Drawdown\n        equity_series = self.equity_curve['equity']\n        running_max = equity_series.expanding().max()\n        drawdown = (equity_series - running_max) / running_max * 100\n        max_drawdown = drawdown.min()\n        \n        # Sharpe ratio\n        returns = equity_series.pct_change().dropna()\n        sharpe_ratio = (returns.mean() / returns.std()) * np.sqrt(252) if returns.std() > 0 else 0\n        \n        # Sortino ratio (downside deviation)\n        downside_returns = returns[returns < 0]\n        downside_std = downside_returns.std()\n        sortino_ratio = (returns.mean() / downside_std) * np.sqrt(252) if downside_std > 0 else 0\n        \n        # Trade duration\n        self.trades['duration'] = (self.trades['exit_date'] - self.trades['entry_date']).dt.total_seconds() / 3600\n        avg_duration = self.trades['duration'].mean()\n        \n        return {\n            'Total Return (%)': round(total_return, 2),\n            'Total Trades': total_trades,\n            'Winning Trades': winning_trades,\n            'Losing Trades': losing_trades,\n            'Win Rate (%)': round(win_rate, 2),\n            'Average Win ($)': round(avg_win, 2),\n            'Average Loss ($)': round(avg_loss, 2),\n            'Profit Factor': round(profit_factor, 2),\n            'Max Drawdown (%)': round(max_drawdown, 2),\n            'Sharpe Ratio': round(sharpe_ratio, 2),\n            'Sortino Ratio': round(sortino_ratio, 2),\n            'Average Trade Duration (hours)': round(avg_duration, 2),\n            'Final Equity ($)': round(self.equity_curve.iloc[-1]['equity'], 2),\n            'Total Profit/Loss ($)': round(self.equity_curve.iloc[-1]['equity'] - self.initial_capital, 2)\n        }\n    \n    def plot_results(self, save_path: str = None):\n        """\n        Plot backtest results\n        \n        Args:\n            save_path: Path to save the plot (optional)\n        """\n        fig, axes = plt.subplots(3, 1, figsize=(15, 12))\n        \n        # Equity curve\n        axes[0].plot(self.equity_curve['date'], self.equity_curve['equity'], label='Portfolio Equity')\n        axes[0].axhline(y=self.initial_capital, color='r', linestyle='--', label='Initial Capital')\n        axes[0].set_title('Equity Curve', fontsize=14, fontweight='bold')\n        axes[0].set_ylabel('Equity ($)')\n        axes[0].legend()\n        axes[0].grid(True, alpha=0.3)\n        \n        # Drawdown\n        equity_series = pd.Series(self.equity_curve['equity'].values, index=self.equity_curve['date'])\n        running_max = equity_series.expanding().max()\n        drawdown = (equity_series - running_max) / running_max * 100\n        axes[1].fill_between(drawdown.index, drawdown.values, 0, alpha=0.3, color='red')\n        axes[1].set_title('Drawdown', fontsize=14, fontweight='bold')\n        axes[1].set_ylabel('Drawdown (%)')\n        axes[1].grid(True, alpha=0.3)\n        \n        # Trade distribution\n        if not self.trades.empty:\n            axes[2].bar(range(len(self.trades)), self.trades['pnl'], \n                       color=['green' if x > 0 else 'red' for x in self.trades['pnl']])\n            axes[2].axhline(y=0, color='black', linestyle='-', linewidth=0.5)\n            axes[2].set_title('Individual Trade P&L', fontsize=14, fontweight='bold')\n            axes[2].set_xlabel('Trade Number')\n            axes[2].set_ylabel('P&L ($)')\n            axes[2].grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        \n        plt.show()\n    \n    def generate_report(self) -> str:\n        """\n        Generate a text report of backtest results\n        \n        Returns:\n            Formatted report string\n        """\n        metrics = self.calculate_metrics()\n        \n        report = \"\"\"\n        ═══════════════════════════════════════════════════════════\n                       BACKTEST PERFORMANCE REPORT\n        ═══════════════════════════════════════════════════════════\n        \n        RETURNS:\n        ───────────────────────────────────────────────────────────\n        Total Return:              {Total Return (%)}%\n        Final Equity:              ${Final Equity ($):,.2f}\n        Total Profit/Loss:         ${Total Profit/Loss ($):,.2f}\n        \n        TRADE STATISTICS:\n        ───────────────────────────────────────────────────────────\n        Total Trades:              {Total Trades}\n        Winning Trades:            {Winning Trades}\n        Losing Trades:             {Losing Trades}\n        Win Rate:                  {Win Rate (%)}%\n        \n        TRADE PERFORMANCE:\n        ───────────────────────────────────────────────────────────\n        Average Win:               ${Average Win ($):,.2f}\n        Average Loss:              ${Average Loss ($):,.2f}\n        Profit Factor:             {Profit Factor}\n        Avg Trade Duration:        {Average Trade Duration (hours)} hours\n        \n        RISK METRICS:\n        ───────────────────────────────────────────────────────────\n        Max Drawdown:              {Max Drawdown (%)}%\n        Sharpe Ratio:              {Sharpe Ratio}\n        Sortino Ratio:             {Sortino Ratio}\n        \n        ═══════════════════════════════════════════════════════════\n        \"\"\".format(**metrics)\n        \n        return report